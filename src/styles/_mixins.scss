@use "sass:map";
@use "sass:math";
@use "variables" as v;

$breakpoints: (
  "mobile": 480px,
  "tablet": 768px,
  "desktop": 1440px,
) !default; //synchronize manually in mixins, brakpoints.ts and index.scss

/// Mixin do obs≈Çugi Media Queries
/// @param {String} $breakpoint
@mixin mq($breakpoint) {
  @if map.has-key($breakpoints, $breakpoint) {
    $value: map.get($breakpoints, $breakpoint);

    @media screen and (min-width: $value) {
      @content;
    }
  } @else if type-of($breakpoint) == number {
    @media screen and (min-width: $breakpoint) {
      @content;
    }
  } @else {
    @warn "There is no such breakpoint: #{$breakpoint}. ";
  }
}

@mixin flex-center($direction: row) {
  display: flex;
  justify-content: center;
  align-items: center;
  flex-direction: $direction;
}

@mixin fluid-type(
  $min-size,
  $max-size,
  $min-breakpoint: 480px,
  $max-breakpoint: 1440px
) {
  @if math.unit($min-size) != "rem" or math.unit($max-size) != "rem" {
    @error "fluid-type expects rem values, got: #{$min-size} and #{$max-size}";
  }

  @if math.unit($min-breakpoint) != "px" or math.unit($max-breakpoint) != "px" {
    @error "fluid-type expects px breakpoints, got: #{$min-breakpoint} and #{$max-breakpoint}";
  }

  $min-size-unitless: math.div($min-size, 1rem);
  $max-size-unitless: math.div($max-size, 1rem);
  $min-bp-unitless: math.div($min-breakpoint, 1px);
  $max-bp-unitless: math.div($max-breakpoint, 1px);

  $slope: math.div(
    ($max-size-unitless - $min-size-unitless),
    ($max-bp-unitless - $min-bp-unitless)
  );
  $y-intercept: -$min-bp-unitless * $slope + $min-size-unitless;

  font-size: clamp(
    #{$min-size},
    #{$y-intercept * 1rem} + #{$slope * 100vw},
    #{$max-size}
  );
}

@mixin absolute($top: null, $right: null, $bottom: null, $left: null) {
  position: absolute;
  top: $top;
  right: $right;
  bottom: $bottom;
  left: $left;
}

@mixin aspect-ratio($width, $height) {
  aspect-ratio: $width / $height;
}

@mixin animated-underline() {
  display: inline-block;
  text-decoration: none;
  color: currentColor;
  will-change: transform; //prevent "jump" at the end of transition

  transition:
    color v.$transition-default 50ms,
    transform v.$transition-default 50ms;

  position: relative;

  &::after {
    content: "";
    position: absolute;
    width: 100%;
    height: 2px;
    bottom: -4px;
    left: 0;
    background-color: v.$highlight-color;

    transform: scaleX(0);
    transform-origin: bottom right;
    transition: transform v.$transition-default 50ms;
  }

  &:hover {
    color: v.$highlight-color;
    transform: scale(1.05);

    &::after {
      transform: scaleX(1);
      transform-origin: bottom left;
    }
  }
}
